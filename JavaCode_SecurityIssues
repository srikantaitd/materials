=====================================	
Denial of Service: Regular Expression
=====================================	
1.
	pulic void fillFruitBasket(String fruits, String basketId)throws Exception {
		try {
			logger.info("The fruits selected by customer are: "  text);
			String[] fruitBasket = text.split(LINE_SEPERATOR);
			logger.info("No of Fruit In Basket Are: " + fruitBasket.length);
		}catch(Exception ex){
			ex.printStackTrace();
		}
	}

2.
	String mt103 = new String(msgTO.getMessageContent());
	mt103 = mt103.replaceAll(System.getProperty("line.separator"), "<BR>");
	
Reason: 
------
Untrusted data is passed to the application and used as a regular expression. This can cause the thread to over-consume CPU resources.	

Solution:
---------
	String[] fruitBasket = fruitBasket.split(ESAPI.validator().getValidInput("Line Separator", LINE_SEPERATOR, "SafeString", 2, false)); 

-----------------------------------------------------------------------------------------------
=============================	
XML External Entity Injection
=============================	
Reason:
-------
XML parser configured here does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.	

Problem Code Snippet-1:
----------------------
	public String handleAcctLienModResponse(String rspMsg, String rxnTransRef, List<TransactionHistPO> tranHistList, List<STPErrorPO> errorList) throws Exception {
		String result = CommonConstants.ACCOUNT_LIEN_RESULT_LIEN_MOD_FAIL;
		
		Reader reader = new StringReader(rspMsg);
		JAXBContext jaxbContext = JAXBContextUtil.newInstance().getJaxbContext(FIXML.class, 
		AcctLienModResponse.class, AcctLienModRequest.class, AcctLienModNotification.class);
		
		Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
		
		FIXML fiXml = (FIXML)unmarshaller.unmarshal(reader);
		result=result.getResult();
		return result;
	}

Solution:
--------
	public void process(){
	 JAXBContext jaxbContext = ... ;
	 Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
	 Reader reader = new StringReader(message);
	 Source xmlSource = new SAXSource(createSAXParser.getXMLReader(),new InputSource(reader));
	 Object o = unmarshaller.unmarshal(xmlSource);
	}
	
	public static final SAXParserFactory createSAXParser()
			throws SAXNotRecognizedException, SAXNotSupportedException, ParserConfigurationException {
		final SAXParserFactory spf = SAXParserFactory.newInstance();
		spf.setFeature("http://xml.org/sax/features/external-general-entities", false);
		spf.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
		spf.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
		spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
		return spf.newSAXParser();
	}
	

Problem Code Snippet-2:
-----------------------
private static final XMLInputFactory inputFactory = XMLInputFactory.newInstance();

private List<Account> processResponse(String acctId,String responseMsg) throws Exception {	
	javax.xml.stream.XMLStreamReader reader = null;
	try {
		inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // This disables DTDs entirely for that factory
		inputFactory.setProperty("javax.xml.stream.isSupportingExternalEntities", false); // disable external entities
		reader = inputFactory.createXMLStreamReader(stringReader);
		// get EnvelopeTO
		Envelope envelope = null;
		envelope = getEnvelope(reader);
			if (envelope != null) {
				final List<Object> anyHeader = envelope.getHeader().getAny();
				//.. do processing
			}
			else{
				//..do alternate processing
			}
	}catch(Exception ex){
		ex.printStackTrace();
	}
}

Solution:
--------	


private List<Account> processResponse(String acctId,String responseMsg) throws Exception {	
	javax.xml.stream.XMLStreamReader reader = null;
	try {
	reader = inputFactory.createXMLStreamReader(new StringReader(responseMsg));
				// get EnvelopeTO
				Envelope envelope = null;
				envelope = getEnvelope(reader);
				if (envelope != null) {
					final List<Object> anyHeader = envelope.getHeader().getAny();
					//.. do processing
				}
				else{
					//..do alternate processing
				}
	}catch(Exception ex){
		ex.printStackTrace();
	}
}



============================
Server-Side Request Forgery:
============================

Code Sample 1:
--------------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

	logger.info(">>call va url:" + url);
	URL restServiceURl = new URL(url);
	HttpURLConnection httpConn = (HttpURLConnection) restServiceURl.openConnection();
	httpConn.setRequestMethod("GET");
	httpConn.setRequestProperty("Accept", "text/html");
	if (httpConn.getResponseCode() != 200) {
		logger.info(">>call va Exception!");
		throw new RuntimeException("HTTP GET Request Failed with error code: " + httpConn.getResponseCode());
	}
Reason:
=======
The function openConnection() on line 47 initiates a network connection to a third-party system using user-controlled data for resource URI. An attacker may leverage this vulnerability to send a request on behalf of the application server since the request will originate from the application server's internal IP address.


Solution1:
---------
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;

import javax.net.ssl.HttpsURLConnection;

import org.apache.commons.lang.StringUtils;
import org.owasp.esapi.ESAPI;
import org.owasp.esapi.errors.EncodingException;

method code snippet:
-------------------
	logger.info(">>call va url:" + url);
	final URL restServiceURl = new URL(ESAPI.encoder().encodeForURL(url));
	final HttpsURLConnection httpConn = (HttpsURLConnection) restServiceURl.openConnection();
	httpConn.setRequestMethod("GET");
	httpConn.setRequestProperty("Accept", "text/html");
	if (httpConn.getResponseCode() != 200) {
		logger.info(">>call va Exception!");
		throw new RuntimeException("HTTP GET Request Failed with error code: " + httpConn.getResponseCode());
	}
	try (InputStreamReader in = new InputStreamReader(httpConn.getInputStream());
			BufferedReader bf = new BufferedReader(in);) {
		if ((output = bf.readLine()) != null) {
			logger.info(">>CustomerAndAccountServiceImpl:va call url,return data:[" + output + "]");
			output = output.replace("[", "").replace("]", "").replaceAll("'", "").replaceAll(" ", "");
			if (StringUtils.isNotBlank(output)) {
				if (output.contains(",")) {
					vaArray = output.split(",");
					logger.info(">>call va sucessful![va:" + vaArray[0] + "][flag:" + vaArray[1] + "]");
				} else {
					vaArray = new String[2];
					vaArray[0] = output;
					vaArray[1] = "";
					logger.info(">>call va sucessful![va:" + vaArray[0] + "][flag:" + vaArray[1] + "]");
				}
			}

		} else {
			logger.info(">>CustomerAndAccountServiceImpl:va call url,return data is empty");
		}
	} catch (final IOException e) {
		throw new IPEBaseException(e);
	}
	

Problem Code Snippet-2:
-----------------------
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.HashMap;
import java.util.Map;

private Socket cSocket = null;

@Override
	public void run() {
		OutputStream os = null;
		ObjectOutputStream oos = null;
		InputStream is = null;
		ObjectInputStream ois = null;

		final Map<String, String> resultMap = new HashMap<String, String>();
		resultMap.put("status", "1");
		try {
			is = cSocket.getInputStream();
			ois = new ObjectInputStream(is);
			os = cSocket.getOutputStream();
			oos = new ObjectOutputStream(os);
			Map<String, String> requestMap = null;
			requestMap = (Map<String, String>) ois.readObject();
			final String countryCode = requestMap.get("countryCode");
			final String jobId = requestMap.get("scheduleJobId");
			final String jobParam = requestMap.get("jobParam");

			//some processing logic
			
		} catch (final Throwable t) {
			//some alternate operation
		} finally {
			try {
				if (oos != null) {
					/***(Security Issue lies here)*/
					oos.writeObject(resultMap);				
				} else {
					logger.error("ObjectOutputStream didn't initialization.");
				}
			} catch (final IOException e) {
				logger.error("", e);
			}	
		}
	}	
	
Reason:
-------
The function writeObject() on line 93 initiates a network connection to a third-party system using user-controlled data for resource URI. An attacker may leverage this vulnerability to send a request on behalf of the application server since the request will originate from the application server's internal IP address.	

Solution For Problem Code Snippet-2:
------------------------------------
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;

import javax.net.ssl.SSLSocket;
import org.apache.commons.io.serialization.ValidatingObjectInputStream;

	@Override
	public void run() {
		final Map<String, String> resultMap = new HashMap<>();
		resultMap.put("status", "1");
		try (InputStream is = cSocket.getInputStream();
				ObjectInputStream ois = new ObjectInputStream(is);
				OutputStream os = cSocket.getOutputStream();
				ObjectOutputStream oos = new ObjectOutputStream(os);) {

			Map<String, String> requestMap = null;
			
			try(ValidatingObjectInputStream objectInStream = new ValidatingObjectInputStream(ois);){
				objectInStream.accept(Map.class);
				requestMap = (Map<String, String>) objectInStream.readObject();
			}
			// requestMap processing business logic

		} catch (final Exception t) {
			logger.error("", t);
			resultMap.put("msg", "Fail to trigger job. " + t.getMessage());
		}
	}
	
====================
Path Manipulation
====================
Problem Code Sample:
--------------------
	try{
		....
		....
		OutputStream outputStreamObject = new FileOutputStream(
							PropertyUtil.getPropertyValue("rxn.properties") + "/" + file.getFileName());
		int bytesRead = 0;
			final byte[] buffer = new byte[8192];
			while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
				bos.write(buffer, 0, bytesRead);
			}
		bos.close();
		stream.close();
	}catch(IOException ex){
		...
	}
	
Reason:
------
Attackers are able to control the file system path argument to FileOutputStream() which allows them to access or modify otherwise protected files.

Solution:
--------

		try (InputStream stream = file.getInputStream();
			OutputStream bos = new FileOutputStream(
					sanitize(PropertyUtil.getPropertyValue("rxn.properties",
							CommonConstants.BulkPaymentConstants.BULK_FXRATE_INBOUND_DIR) + "/"
							+ file.getFileName()));) {
			int bytesRead = 0;
			final byte[] buffer = new byte[8192];
			while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {
				bos.write(buffer, 0, bytesRead);
			}
			context.addMessage("message", new Message("msg.maintenance.agentBankRate.upload.success"));
			Arrays.fill(buffer, (byte) 0);
		} catch (final Exception e) {
			...
		}

	public static final String sanitize(final String message) {
		if (message == null || message.length() == 0)
			return "";
		final StringBuilder cleanString = new StringBuilder(message.length());
		for (int i = 0; i < message.length(); ++i) {
			cleanString.append(cleanChar(message.charAt(i)));
		}
		return cleanString.toString();
	}

	private static final char cleanChar(final char aChar) {
		// 0 - 9
		for (int i = 48; i < 58; ++i) {
			if (aChar == i)
				return (char) i;
		}
		// 'A' - 'Z'
		for (int i = 65; i < 91; ++i) {
			if (aChar == i)
				return (char) i;
		}
		// 'a' - 'z'
		for (int i = 97; i < 123; ++i) {
			if (aChar == i)
				return (char) i;
		}
		// other valid characters
		switch (aChar) {
		case '/':
			return '/';
		case '.':
			return '.';
		case '-':
			return '-';
		case '_':
			return '_';
		case ' ':
			return ' ';
		case ':':
			return ':';
		}
		return '%';
	}
-----------------------------------	-----------------------------------

in Javascript:
Cross-Site Scripting: Reflected
===============================
Code Snippet:
-------------	
	...
	 if(!found){
    	document.getElementById("assignToIdv").value = value;
    }     
    var firstTimeOpened = '<%=firstTimeOpened%>';
   	if (document.getElementById("searchId") !=null )
   	{
   		if (firstTimeOpened == 'T')	
   			document.getElementById("searchId").disabled=false;
   		else
   			document.getElementById("searchId").disabled=true;
   	}	
	...
	...
	
Reason:
------
The method _jspService() in archival_enquiry_main_search.jsp sends unvalidated data to a web browser on line 282, which can result in the browser executing malicious code.	

Solution:
---------
<%@page import="org.owasp.esapi.ESAPI"%>

<script type="text/javascript">
<%
String firstTimeOpened = ESAPI.encoder().encodeForJavaScript(request.getParameter("firstTimeOpened"));
if (firstTimeOpened == null) {
	firstTimeOpened = "";
}
%>
</script>

	
Notes On XSS Issue:
------------------
Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end data store.


In this case the data enters at getParameter() in FIRCCertificate_main_search.jsp at line 31.

2. The data is included in dynamic content that is sent to a web user without being validated.

In this case the data is sent at print() in FIRCCertificate_main_search.jsp at line 98.

The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.


Example 1: The following code reads an employee ID, eid, from an HTTP servlet request, then displays the value back to the user in the servlet's response.


String eid = request.getParameter("eid");
...
ServletOutputStream out = response.getOutputStream();
out.print("Employee ID: " + eid);
...
out.close();
...


Example 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user.


<% String eid = request.getParameter("eid"); %>
...
Employee ID: <%= eid %>



The code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.


Example 2: The following code segment queries a database for an employee with a given ID and prints the corresponding employee's name in the servlet's response.


...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
rs.next();
String name = rs.getString("name");
}

ServletOutputStream out = response.getOutputStream();
out.print("Employee Name: " + name);
...
out.close();
...


Example 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.


<%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
rs.next();
String name = rs.getString("name");
}
%>

Employee Name: <%= name %>



As in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

Some think that in the mobile world, classic web application vulnerabilities, such as cross-site scripting, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code enables JavaScript in Android's WebView (by default, JavaScript is disabled) and loads a page based on the value received from an Android intent.


...
WebView webview = (WebView) findViewById(R.id.webview);
webview.getSettings().setJavaScriptEnabled(true);
String url = this.getIntent().getExtras().getString("url");
webview.loadUrl(url);
...


If the value of url starts with javascript:, JavaScript code that follows will execute within the context of the web page inside WebView.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- As in Example 3, a source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content. 


Recommendations:
=================

The solution to XSS is to ensure that validation occurs in the correct places and checks for the correct properties.

Since XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application may accept input through a shared data store or other trusted source, and that data store may accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alpha-numeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser should still be considered valid input once they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. In order to form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and may treat other characters as special in certain contexts, which is why we do not encourage the use of blacklists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "<" is special because it introduces a tag.

- "&" is special because it introduces a character entity.

- ">" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "<", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&" is special when used with certain attributes, because it introduces a character entity.

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a <SCRIPT> </SCRIPT>:

- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering.

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '<' appears as '+ADw-' and may bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

Once you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and may be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.


Tips:

1. The Fortify Secure Coding Rulepacks warn about SQL Injection and Access Control: Database issues when untrusted data is written to a database and also treat the database as a source of untrusted data, which can lead to XSS vulnerabilities. If the database is a trusted resource in your environment, use custom filters to filter out dataflow issues that include the DATABASE taint flag or originate from database sources. Nonetheless, it is often still a good idea to validate everything read from the database.

2. Even though URL encoding untrusted data protects against many XSS attacks, some browsers (specifically, Internet Explorer 6 and 7 and possibly others) automatically decode content at certain locations within the Document Object Model (DOM) prior to passing it to the JavaScript interpreter. To reflect this danger, the rulepacks no longer treat URL encoding routines as sufficient to protect against cross-site scripting. Data values that are URL encoded and subsequently output will cause Fortify to report Cross-Site Scripting: Poor Validation vulnerabilities.

3. Fortify RTA adds protection against this category.


References:

[1] Understanding Malicious Content Mitigation for Web Developers, CERT, http://www.cert.org/tech_tips/malicious_code_mitigation.html#9

[2] HTML 4.01 Specification, W3, http://www.w3.org/TR/html4/sgml/entities.html#h-24.2

[3] Tongbo Luo, Hao Hao, Wenliang Du, Yifei Wang, and Heng Yin, Attacks on WebView in the Android System, http://www.cis.syr.edu/~wedu/Research/paper/webview_acsac2011.pdf

[4] Erika Chin and David Wagner, Bifocals: AnalyzingWebView Vulnerabilities in Android Applications, http://www.cs.berkeley.edu/~emc/papers/Chin-WISA-WebViews.pdf

[5] INJECT-3: XML and HTML generation requires care, Oracle, http://www.oracle.com/technetwork/java/seccodeguide-139067.html#3

[6] INPUT-1: Validate inputs, Oracle, http://www.oracle.com/technetwork/java/seccodeguide-139067.html#5

